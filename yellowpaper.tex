\documentclass[a4paper, 10pt, conference]{ieeeconf}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{pgf-pie}
\usepackage{tikz}
\usetikzlibrary{positioning,shadows,arrows}

\usepackage{xcolor}
\newcommand\todo[1]{\textcolor{red}{\textbf{TODO}: [#1]}}

\IEEEoverridecommandlockouts
\overrideIEEEmargins

\title{\LARGE \bf
Stegos  -- a design for a private, confidential and scalable cryptocurrency}
\author{The Stegos Team, October 2018}%

\begin{document}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}

    On October 31\textsuperscript{th} of 2008, a person or group named ‘Satoshi Nakamoto’ released a paper called ``Bitcoin: A Peer-to-Peer Electronic Cash System.''\cite{c1} In ten years that passed since that date, Bitcoin became the main cryptocurrency in the world and inspired a lot of researchers and developers to create their own blockchains that are building and improving on Bitcoin and its ideas.
    
    One of the areas of improvement is privacy --- despite the fact that payments in Bitcoin are conducted between pseudonymous users, the payment transactions are stored in a public decentralized ledger, from which a lot of information can be deduced. More than a dozen of \textit{privacy coins} exists at the moment, each of which uses sophisticated algorithms in order to keep privacy of its users protected. 
    
    Despite that long list of privacy-centered blockchains, all of them have some substantial drawbacks. Some of the privacy coins protect identities of senders and recipients, but keep transaction amounts in open. Almost all of the existing privacy coins cannot be scaled, because their ledger must be ever-growing and cannot be compacted. Most part of these coins use Proof-of-Work consensus which is obviously unfriendly to the environment because it wastes enormous amounts of electricity. 
    
    In this paper we propose a design for a private, confidential, and scalable cryptocurrency that’s friendly to the environment. This design builds and improves upon other privacy coins and can be used to send payments and data with complete confidentiality. 

\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

In this section we give brief overview of most prominent privacy coins and analyze their privacy-protecting and performance characteristics.

We also explain, on a high-level, how Stegos builds and improves on existing privacy coins ideas and employs latest research in cryptography and blockchains in order to create privacy-preserving blockchain that can be scaled. 

\subsection{Terminology}

Here we give definitions for miscellaneous terms that we are using troughout this paper:

\begin{itemize}

\item \textbf{Privacy}: protection from detection of the identity of blockchain participants and parties to transactions.
\item \textbf{Confidentiality}: protection from analyzing blockchain data (e.g. transaction details, including amounts) by unauthorized third parties.
\item \textbf{Unlinkability}: for any two outgoing transactions it is impossible to prove they were sent to the same person\cite{c2}.
\item \textbf{Untraceability}: for each incoming transaction all possible senders are equiprobable\cite{c2}.
\item \textbf{Compactness}: spent coins can be pruned from the blockchain and the blockchain can be compacted.
\item \textbf{Sharding}: a transaction verification and block sealing processes can be partitioned between participants or groups of participants.
\item \textbf{Interactivity}: senders and recipients of transactions must interact with each other \textit{off-chain} before posting a transaction to the blockchain.
\item \textbf{Trusted Setup}: blockchain participants need to trust someone to generate some initial parameters and then destroy those parameters.
\item \textbf{PoW}: Proof-of-Work, an original consensus protocol for Bitcoin, where each node participating in the protocol should present a piece of data which is difficult (costly, time-consuming) to produce but easy for others to verify and which satisfies certain requirements. Due to complexity of computations needed and amount of miners, the current energy consumption by Bitcoin PoW consensus is approximately 73TWh per year\footnote{https://digiconomist.net/bitcoin-energy-consumption}.
\item \textbf{PoS}: Proof-of-Stake \todo{insert def.}
\item \textbf{UTXO}: Unspent Transaction Output \todo{insert def.}

\end{itemize}

\subsection{Existing privacy coins}

\subsubsection{Monero}

originated as a Bytecoin fork in 2014 under the name Bitmonero. The cryptocurrency is using UTXO model and PoW consensus, and based on the CryptoNote protocol\cite{c2}, employing the ring signatures method. In 2017 Monero implemented RingCT\cite{c3}, an improved version of the ring signatures. RingCT is enabling a confidentiality of amounts and untraceability of transactions. In combination with the stealth addresses (also introduced in the original CryptoNote paper), which provide unlinkability of recipients, this provides full privacy and confidentiality.

Monero's blockchain cannot be compacted because spent UTXOs cannot be pruned from it. Keeping all UTXOs forever is one of the requirements of RingCT protocol, which obfuscates the fact which particular UTXOs mentioned in transaction inputs were actually spent. 
Despite the recent introduction of Bulletproofs\cite{c4} which replaced Monero's original zero knowledge range proofs and got a simple transaction size from 13KB down to 2.5KB, the problem with ever-growing blockchain cannot be solved. 

\subsubsection{ZCash}

originated in 2016 as Bitcoin fork and obviously is using UTXO model and PoW consensus. The goal of the project is to improve the flaws of Bitcoin, with a focus on privacy. The project is building on a work done on Zerocoin\cite{c5}, addressing some of its faults, like the size of the proofs, which ZCash decreases to 1KB and speeds up the verification.

For establishing confidentiality and untraceability, ZCash implements ``Zero-Knowledge Succinct Non-Interactive Argument of Knowledge'' (zk-SNARKS)\cite{c6}. For providing unlinkability of recipients, ZCash employs the stealth addresses.

zk-SNARKS enable a large anonymity set of all minted coins, providing a high degree of privacy. However, the size of up to 2 kB for average transaction and ever-growing accumulator that cannot be pruned, makes ZCash much less scalable. The issue of
scalability is the main reason why the privacy is currently optional, not by default. At the time of writing, less than 25\% of all transactions were shielded.

The questionable part of zk-SNARKS protocol is the initial trusted setup. ZCash utilized a multi-party ceremony involving a 6-person set up. This is controversial, as you have to trust any of
these 6 people that they destroyed the initial parameters and also trust that the ceremony was carried out correctly. 

\subsubsection{Dash}

originally a codebase fork from Litecoin (which is in turn a codebase fork of Bitcoin), Dash were launched as XCoin in January 2014. Dash is using UTXO model and PoW consensus. 

Besides standard nodes and miners, Dash has \textit{masternodes}, the nodes that must have static IP address and fullfil particular requirements for CPU, RAM, and disk space. Each masternode must have at least 1000DASH in its ownership. A Proof-of-Service protocol ensures that masternodes have the most current blockchain protocol and are online. 

It is important to note that privacy is optional in Dash and the high volume of transactions is driven mainly by the fast public transactions called \textit{InstantSend} which are provided by masternodes.

\textit{PrivateSend} is an implementation of CoinJoin, the untraceability solution first proposed for Bitcoin by Bitcoin Core developer Gregory Maxwell\footnote{https://bitcointalk.org/index.php?topic=279249.0}. In PrivateSend, three users add their coins together in one big transaction, that sends the coins to freshly generated addresses belonging to the same three users. As such, the coins are effectively mixed between the three participants, breaking the blockchain trail of ownership between them. This process can be automatically repeated up to eight times, with (hopefully) different mixing participants, for extra privacy.

Dash is not providing confidentiality of amounts neither in InstantSend, nor in PrivateSend. Moreover, it is essential requirement of CoinJoin protocol that inputs of users involved in the round of the mixing protocol must have exactly the same denomination (amount of coins). This requirement is impossible to fullfil in case if amounts are cloaked. 

Users of Dash have to trust masternodes that they will keep users' IP addresses not disclosed and not linked to users' UTXOs when sending transactions in Dash. This adds another privacy vulnerability to Dash.

\subsubsection{Mimblewimble (Grin)}

is a protocol that was proposed by an anonymous user in a Bitcoin developers chatroom by the name of Tom Elvis Jedusor, that left a link to a paper\footnote{https://download.wpsoftware.net/bitcoin/wizardry/mimblewimble.txt} in which he outlines that by using the Mimblewimble protocol, the scalability, as well as the privacy of the Bitcoin network could significantly be enhanced.

Mimblewimble is based on the ideas of Greg Maxwell's design for Confidential Transactions\footnote{https://people.xiph.org/\texttt{\~{}}greg/confidential\_values.txt},  except, it is the recipient that generates random blinding factor used to cloak the amount of the transaction. This blinding factor is then used as proof of ownership by the recipient, therefore working simultaneously as recipient's public key. Therefore Mimblewimble provides confidentiality of amounts and unlinkability of recipients in its transactions.

Untraceability of transactions in Mimblewimble is building on the ideas of CoinJoin and is implemented by breaking transaction boundaries and storing only inputs and outputs of all transactions verified by miner in a new mined block.

The only existing implementation of the protocol known to the moment is Grin project\footnote{https://github.com/mimblewimble/grin}, which has recently released the third iteration of their testnet. Grin uses UTXO model and PoW consensus. Spent UTXOs in Grin can be pruned, by recursively applying simple pruning algorithm for each UTXO referenced in inputs of the new minted block.

There are several drawbacks in the design of Mimblewimble and Grin:

\begin{itemize}

\item{First is related to the transaction creation mechanism of Mimblewible and Grin --- in order to create a transaction, a sender and recipient must interact with each other. The sender cannot post a transaction to the blockchain without first contacting the recipient with half-baked transaction data and receiving that data updated by applying a blinding factor back from the recipient.}
\item{Second is very similar to the problem that Dash where users should trust Dash masternodes. Currently, users of Grin should trust Grin miners that miners will not trace the history of moving coins inputs to outpus in transactions, and discard this data completely after mining a block. Therefore there is a potential threat to coin's fungibility and privacy of the users.}

\end{itemize}

\subsection{Our contribution}

In this paper we propose a design of \textit{Stegos}, a blockchain which uses the \textit{UTXO} (coin) model and \textit{PoS} (Proof-of-Stake) consensus.

Transactions in Stegos are \textit{unlinkable}, \textit{untraceable}, and \textit{confidential}:

\begin{itemize}

\item{Stegos uses one-time payment addresses which make it impossible to identify recipients of a transaction (in another words, to link addresses of recipients to their identities) because all transactions are directed to new and unique addresses. The technique used for one-time addresses is very similar to stealth addresses used in Monero and ZCash.}

\item{Stegos makes it impossible to trace history of transactions since many individual transactions are pooled together to form a super-transaction. For this purpose we adopted and enhanced ValueShuffle protocol\cite{c7}, the first coin mixing protocol compatible with Confidential Transactions.}

\item{All amounts in Stegos are hidden using Pedersen commitments\cite{c8} and Bulletproofs range proofs\cite{c4}. Validator stakes and transaction fees are the only exception since these must be visible for blockchain validation.}

\end{itemize}

Stegos is a \textit{compact} blockchain. Spent coins are safely removed from the blockchain using secure cryptographic pruning. To keep our blockchain free of spent coins we are using the technique proposed originally by Satoshi Nakamoto in Bitcoin paper\cite{c1}.

Stegos uses transactional \textit{sharding} to scale. Separate gro\-ups of Stegos validators keep the whole blockchain state but verify only a subset of incoming transactions, using cross-shard atomic commits to eliminate double-spending. This scalability approach lets Stegos process hundreds of thousands of transactions per second.

Stegos is friendly to the environment and does not require terawatts of electricity to be spent for mining blocks. Stegos is using PoS (Proof-of-Stake) consensus, building on ideas of pBFT\cite{c9} and Collective Signing\cite{c10}\cite{c11}. Each new Stegos block must be verified and confirmed by a group of validators, all of which must put coins in escrow (stake).

The size of the coins staked has a direct effect on the probability of a validator to become a leader of the consensus and earn transaction fees. Stegos does not have block rewards but replaces them with the \textit{Jackpot}.

This is a feature unique to Stegos and a lottery concept that everyone is familiar with. A portion of the fees from each block are added to the Jackpot and any stake forfeited by a validator caught cheating goes into the Jackpot as well.

The Jackpot is distributed every few thousand blocks when validators run a cryptographic lottery based on verifiable distributed randomness. The amount in the Jackpot is then transferred to the winner. The longer a validator keeps its stake and participates in consensus, the higher the probability of winning the Jackpot lottery.

Electing a leader of the consensus and choosing a winner in the Jackpot lottery use our algorithm for generating distributed, untainted, unbiasable randomness, in the spirit of the RandHound protocol\cite{c12}. Our algorithm actually derives much of its protocol from SCRAPE\cite{c13} as its primary deviation from original RandHound. SCRAPE defines a PVSS\cite{c14} protocol using symmetric bilinear pairing based cryptography and coding theory. But beyond SCRAPE, we had to adjust the algorithm to deal with asymmetric pairings which offer necessary stronger cryptographic security.

In the following sections we will explain each of the Stegos features presented above in more details. In Section \ref{transactions}, we describe how UTXOs and basic transactions composed in Stegos. \todo{add descriptions of other sections}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Transactions} \label{transactions}

\subsection{UTXO composition}

For illustrative purposes, suppose that some coins have been sent from Alice to Bob. Alice's public key is $P_A$, while Bob's secret key is $s_B$ and his public key is $P_B$. To help preserve anonymity, all public keys in Stegos are cloaked with a random value chosen from a very large finite field, $Z_r$.

When Alice sends coins to Bob, she cloaks their amount with a Pedersen commitment, which is both binding and hiding. It binds Alice to her commitment so that she can never alter the amount of coins. The commitment also hides the amount from the general public, while simultaneously providing proof to the public that the amount is legitimate.  Only Alice and Bob know how many coins are being transferred. 

To form a Pedersen commitment, Alice multiplies the amount by a generator, $A$ for the Elliptic curve group, $E_q$, of prime order $r$. To that she cloaks the commitment by adding a multiple, $\gamma$, of the publicly known generator point, $G$, with the multiple being chosen randomly from the finite field, $Z_r$. Generators $A$ and $G$ must have no known relationship. Placing the cloaking factor on the main generator curve will become important as we proceed. This is the same curve which holds all public keys. 

The Pedersen commitment is thus:
$$ C(x, \gamma) = x \, A + \gamma \, G \in E_q$$
$$x, \gamma \in Z_r$$

where $x$ denotes the number of coins being transferred, $A$ is the amount-curve generator, and $G$ is the principal generator. We denote the commitment by $C(x, \gamma)$. 

This commitment value will be wrapped inside a range proof on the amount, $x$, called a ``Bulletproof'', which also proves that the amount lies within a legitimate range of values, typically a 64-bit number.

Alice then cloaks Bob's public key with factor, $\delta \in Z_r$, and leaves a record of the amount $x$, and cloaking factors, $\gamma$ and $\delta$, in an encrypted payload as a part of the \textit{UTXO} awaiting Bob. She forms a UTXO $\mathit{ID}$ by hashing the rest of the UTXO record, which contains the cloaked version of Bob's public key, $P_{B, \delta}$, the Bulletproof, and the encrypted payload. 

The UTXO $\mathit{ID}$ becomes a unique identifier, since, if all else were equal, the $\gamma$ and $\delta$ factors were randomly chosen from field $Z_r$.

\begin{align*}
UTXO &= (ID, P_{B, \delta}, Bp, E_B(x, \gamma, \delta))
\end{align*}
where
\begin{align*}
ID &= H_r(P_{B, \delta}, Bp, E_B(x, \gamma, \delta)) \in Z_r \\
H_r(arg_1, arg_2, ...) &= \textit{hash mapping of concat args} \rightarrow Z_r \\
P_{B, \delta} &= P_B + \delta \, G \\
G &= \textit{known generator for group } E_q \\
Bp &= \textit{Bulletproof of range on amount}, x \\
E_B(x, \gamma, \delta) &= \textit{Encrypted payload}
\end{align*}

$E_B(x, \gamma, \delta)$ represents an encrypted packet containing the information about $x$, $\gamma$, and $\delta$, in a form that only Bob can read.

The Bulletproof contains the Pedersen commitment discussed above, as well as providing a range proof on the amount, $x$. Everyone knows the $E_q$ group generators, $G$ and $A$. Alice's complete transaction record contains additional information that we'll discuss below.

Nowhere is either of Alice's or Bob's public key shown. We only present a cloaked version of Bob's key. And since $\delta$ is a secret value, nobody can recover the actual public key underlying the cloaked version. 

\textit{Therefore Bob may publish his public key openly, i.e. on his website or in the invoice, and don't worry that his identity will be linked to the recipient of the payment on Stegos blockchain, because his public key will appear in Stegos UTXOs always in a cloaked from -- every time as a new and random number.}

\subsection{Basic Transactions}

When Bob wants to spend his new tokens, he must form a transaction containing a list of inputs (TXINs) and outputs (TXOUTs). TXINs are nothing more than the $\mathit{ID}$s referring to other UTXOs. TXOUTs are a list of new UTXOs. He must also offer a valid signature on the entire transaction, which simultaneously proves his ownership of all TXIN's, proves that the transaction carries zero net balance of funds between TXINs, TXOUTs and fees, and protects the contents of his transaction against mutation by MITM attackers.

A UTXO can only be spent in its entirety, and if it carries excess value for his purposes, he will produce a TXOUT with change back to himself, thereby creating a new UTXO. Bob must show that the sum of all inputs to his transaction equals the sum of all outputs plus fee. And he can do so with Pedersen commitments so that his transaction is binding on him, while also disclosing nothing about the actual amounts involved.

To form his signature, he adds together all the $\delta$ cloaking factors from the UTXOs specified by his TXINs list of $\mathit{ID}$s, adds in all the $\gamma$ cloaking factors from the Pedersen commitments in the Bulletproofs from those same UTXOs, and subtracts the $\gamma$ cloaking factors used in his own TXOUT UTXOs. 

Suppose Bob uses $N$ TXINs. His own public key, $P_M = s_M \, G$. Then his effective secret key for the signature becomes:
$$s_{\mathit{eff}} = N \, s_M + \sum_{i \in \text{ins}} {\delta_i} + \sum_{i \in \text{ins}}{\gamma_i} - \sum_{j \in \text{outs}}{ \gamma_j}$$

Using this effective secret key, he produces a Schnorr signature pair, $(u, K)$, after choosing $k \in Z_r$ at random:
$$K = k \, G$$
$$u = k + H_r(T, K) \, s_{\mathit{eff}}$$
$$Sig(M,T) = (u, K)$$
so that validators can see that:
$$u \, G = K + H_r(T, K) \, P_{\mathit{eff}}$$
$$P_{\mathit{eff}} = \sum_{i \in \text{ins}}{P_i} + \sum_{i \in \text{ins}}{C_i} - \sum_{j \in \text{outs}}{C_j} - \mathit{Fee} \, A$$
where $T$ represents the entire transaction record, sans signature.

Let's examine the commitment terms. Pedersen commitments are additively homomorphic:
$$C(x_1, \gamma_1) + C(x_2, \gamma_2) = C(x_1 + x_2, \gamma_1 + \gamma_2)$$

Hence, if Bob's transaction is valid, the amount terms in the effective public key show a zero balance on the $A$ curve, after subtracting off the $\mathit{Fee}$. What remains is entirely on the $G$ curve. The validator sum becomes another public key on the $G$ curve, exactly matching her own computed effective secret key, $s_{\mathit{eff}}$. Only Bob could form a valid signature since it relies on his secret key. It is unforgeable. Both Alice and Bob know all the other secret items, $\gamma$'s and $\delta$'s. Nobody else knows any of the secret values.

Suppose Bob now just wants to send the coins she received from Alice on to Charlie, after deducting fees. In that case, Bob forms a UTXO that uses a different blinding factor, $\gamma_2$, and different key cloaking value, $\delta_2$, and which contains amount, $(x - \mathit{Fee})$. Bob must form a new Bulletproof on the amount, and encrypt these values into a payload that only Charlie can read:
$$ID' = H_r(P_{S, \delta_2}, Bp', E_S(x - Fee), \gamma_2, \delta_2))$$
where $P_{C, \delta_2}$ is Charile's cloaked public key for this transaction. 

Charlie can spend this UTXO by providing a valid transaction signature against the UTXO \textit{ID'}, just like Bob did for his own input. 

Bob's TXOUT will now look like this:
$$\text{TXOUT} = (ID', P_{S, \delta_2}, Bp', E_S(x - Fee, \gamma_2, \delta_2))$$

To wrap up, Bob publishes the transaction:

\begin{align*}
\text{T} = \{&\text{TXIN} : \{\mathit{ID}\}, \\
 &\text{TXOUT} : \{(\mathit{ID'}, P_{S, \delta_2}, \mathit{Bp'}, E_S(x - \mathit{Fee}, \gamma_2, \delta_2))\}, \\
 &\text{FEE} : \mathit{Fee}, \\
 &\text{GAMMA} : \gamma_{\mathit{adj}} = \sum_{i \in \text{ins}}{\gamma_i} - \sum_{j \in \text{outs}}{\gamma_j}\\
 &\text{SIG} : \mathit{Sig}(M, T)\}
\end{align*}

The first line is Bob's TXIN referencing the UTXO produced for him by Alice. The second line is the TXOUT - a new UTXO aimed at Charlie. The third line shows the fees paid for this transaction, in clear text form. 

The fourth line shows what value of $\gamma$ adjustment, on the $G$ curve, is needed to see that the sum of input commitments equals the sum of output commitments, proving a zero net balance between TXINs and TXOUTs and Fee. This information is redundant in the sense that a valid signature on the transaction already proves this. But future coalescing of transactions, e.g. in the blockchain, needs to know the individual $\gamma_{\mathit{adj}}$ factors in order to produce a valid collection from individual transactions.

The final line is Bob's signature asserting ownership of all TXINs, valid zero balance on the transaction, and serves as a checksum against mutation of the contents of this transaction. If anything becomes changed in this record, the signature won't check. Hence our transactions are non-malleable.

%%%%%%%%%%%%%%%
\subsection{Pooled Transactions}
We just saw that, even though participant's identities are cloaked in the blockchain, a record of ancestry for every UTXO could be generated by linking together all the TXIN UTXO references. To counteract that, we want to utilize a protocol that hides knowledge about the origin of output UTXO's.

We want to protect individuals who don't want any record that they contributed to some cause. They may wish to remain publicly anonymous. And already, we don't ever identify any persons since all keys shown in the blockchain are cloaked. But there remains a trail of UTXO to UTXO that could be followed. And with metadata from other sources, some person might become identified, leading to other possible identifications in a cascading manner, just from knowing the ancestry of an individual UTXO.

The difficulty follows from the fact that UTXO's must have identifiable characteristics. Their ID's are unique. Without that, no witness could ever validate transactions, and there would be no way to prove ownership. But that ID leads to an inevitable trail. We want to obscure that trail by showing only that a UTXO could have come from one or more of many different and unrelated inputs. We want to ensure that nobody can tell what its source was. Nobody can see who the payee is. Nobody can see who the payer was. Everything in the system is fully cloaked, but done so in a manner allowing public validation.

There are two possible approaches to this: Ring Signatures, and ValueShuffle. Ring Signatures collect together a large number of UTXO, at random, from the blockchain, and add those into the list of actual TXIN UTXO's being spent. A signature is formed on all of the TXIN, so that you can prove that one group of TXIN are being spent properly, but nobody can determine which ones. The problem with this approach is that you can't ever know, therefore, if a UTXO becomes spent and could be trimmed from the blockchain. All UTXO that ever existed must be retained in the blockchain. That doesn't scale very well.

ValueShuffle also pools together TXIN's to confuse the determination of UTXO source. But in this case, all TXIN are valid components of individual transactions. Multiple individual transactions are combined, over a secure communication channel, in cooperation with other spenders, to produce one large super-transaction. All mentioned TXIN UTXO are being spent, so we can now trim the blockchain. By pooling a large number of TXIN and TXOUT, there is no way to determine the source of any TXOUT UTXO. All you can know, just like with Ring Signatures, is that a UTXO came from one or more of the mentioned TXIN's.

%%%%%%%%%%%%%%%%%%
\subsection{Our Pooling Protocol}
A wallet signals its desire to join a pooling group by advertising a fresh ephemeral public key, along with signature proof of validity, on a bulletin board. Once a group forms, the key will become part of an advertised key collection. This key collection is then sorted in ascending numerical order, the hash of the collection is formed, and that hash becomes a random seed for the session.

A leader is selected by forming the XOR of the hash value with their public key, and if the resulting value is the minimum in the list, that node has been chosen as leader. Leader is responsible for publication of final super-transaction. All other communications are P2P between members of the group.

All nodes in the group will broadcast their list of TXIN's along with signatures validating ownership of the TXIN's. Every participant can validate the lists from other participants by verifying the signature attesting to TXIN ownership. Participants should check that the public key in the signature is from one of the group members.

A valid signature on the TXIN's from one participant is formed by sending a Schnorr signature on the sum of the cloaked public keys shown in the referenced UTXO's in the blockchain:

\begin{align*}
TXIN &= \{ID_1, ID_2, ..., ID_N\}\\
Sig &= (u, K)\\
K &= k \, G \\
u &= k + H(K | ID_1 | ID_2 | ...) \, (N \, s + \sum_i{\delta_i})
\end{align*}

where the sum is over the list of TXIN's, $s$ is the owner's secret key, and the $\delta_i$ were the cloaking factors used on the public key of the owner. $N$ refers to how many TXIN there are in the list. Value $k$ is chosen randomly from the field, $Z_r$. 

Verification of a signature is by seeing that:
$$u \, G = K + H(K | \mathit{ID}_1 | \mathit{ID}_2 | ...) \sum_i{P_i}$$
where the $P_i$ are the cloaked public keys shown in the UTXO's corresponding to each $\mathit{ID}_i$. This signature proves ownership of the stated TXIN UTXO's.

Nothing in this broadcast identifies the sender, but one cannot count on that to hold. In the event of misbehavior, a blame cycle will require each node to submit all their shared secret keys, which effectively reveals their full transactions. A restart will compute new TXOUT so that a successful run ensures anonymity of participants. But if a blame cycle is performed there is no way to cloak the associations to TXIN's again.

Once contributions have been received from each participant, or a timeout occurs, the resulting pool of TXIN is known to all participants. Since these are merely UTXO ID's pointing into the immutable blockchain, no further changes can occur to this list except for removal of individual TXIN references as some participants are found to go offline during the protocol, or else when a cheater is detected and then excluded for a restart of the protocol.

All participants will establish pair-wise shared secret keys between themselves and every other participant in the P2P network. These shared keys are used to form cloaking factors in the anonymizing protocol, such that, only after pooling results from all participants, will the collection of data shared among them become apparent. Until that time, all information remains cloaked. And after that time, the data will be known, but no associations can be inferred regarding who supplied which portions of the data. 

It is important to the protocol, that between any two users, both of them are using the same shared secret cloaking key. Only then will the sum of all cloaking factors, from all participants, cancel out in the DiceMix arrays. But users are prevented from seeing each other's secrets since the total cloaking factor also sums contributions related to all other participants, and those keys are unknown to the other party.

Shared keys can be securely established between every pair of participants using Diffie-Hellman secure key exchange. With two participants, $A$ and $B$, this can be established by having $A$ send to $B$
$$A \rightarrow B: (\alpha \, P_B, \mathit{Sig}(P_A))$$
for $\alpha$ randomly chosen by $A$, and where $\mathit{Sig}(P_A)$ securely authenticates this information as having come from $A$. The signature includes the public key, $P_A$. 

Then $B$ responds to $A$ with
$$B \rightarrow A: (\beta \, P_A, \mathit{Sig}(P_B))$$
with $\beta$ being chosen randomly by $B$. 

After the exchange, the shared key is a hash of the product:
$$key = H(\alpha \beta \, G)$$ 
But since neither side knows both factors, at $A$ we compute:
$$\beta \, G = (\beta \, P_A) / s_A$$
since $P_A = s_A \, G$. And at $B$ we compute
$$\alpha \, G = (\alpha \, P_B) / s_B$$
Then each side can multiply their result by their chosen randomness to reveal $(\alpha \beta \, G)$. Nobody watching the exchange can deduce the shared secret key.

Next, each participant computes their TXOUT records with fresh randomness, chooses random $k$-factors for an eventual collective Schnorr signature, and produces both a DiceMix array containing the fragmented TXOUT records, and cloaked running sums of their $\gamma_{\mathit{adj}}$ and $K$-signature values. The hash commitment of this information is signed and broadcast to all participants. This commitment will be used to verify information during the following passes to verify that information was properly transmitted.

The DiceMix array contains successive powers of their TXOUT record fragments, cloaked with self-canceling seeds that zero out after all participants pool their results from the next pass. After forming the DiceMix array and running sums, this information is signed and broadcast to all participants. Anonymity is assured because of the DiceMix cryptographic mixing process. Even though all participants can see, from the accompanying signature, who delivered a DiceMix array, they cannot see which components of the collection were contributed by any participant. The entire collection is revealed only after summing the DiceMix arrays from all participants.

The individual $K$-signature terms from each participant are summed in a blind sum. We do this to prevent combinatorial exploration, once signature $u$-values are disclosed, which could lead to associations between TXIN and TXOUT.

On receipt of all DiceMix arrays and the running sums, each participant can form the polynomial, using Newton's Identities, whose roots are the individual contributions. Solving that polynomial for its roots reveals each component of participant TXOUT's. These TXOUT's are reassembled, and a super-transaction is formed containing all TXIN's, TXOUT's, the $\gamma_{\mathit{adj}}$ sum needed to show zero balance, and the $K$-signature sum needed for a collective Schnorr signature.

Each participant validates the entire transaction for correctness by examining the $\gamma$ sums for zero balance, and verifying the TXOUT Bulletproofs. They must also find their own contributions in the list of TXIN and TXOUT. If the super-transaction does not properly validate, then someone has cheated, and we enter a blame discovery cycle. Otherwise we proceed to the formation of the collective signature. 

Knowing the super-transaction, and the collective $K_{\mathit{sum}}$ signature term, each participant broadcasts their $u$-signature component to be summed with those of other participants, yielding a collective Schnorr signature on the whole super-transaction.

Signature formation on the super-transaction for each participant is done as follows;

\begin{align*}
T &= \text{super-transaction} \\
Sig_i &= (u_i, K_{sum}) \\
K_{sum} &= \sum_i{k_i \, G} \\
s_{cmp} &= N \, s_i + \sum_{j \in \text{ins}} {\delta_j} + \sum_{j \in \text{ins}} {\gamma_j} - \sum_{k \in \text{outs}} {\gamma_k} \\
u_i &= k_i + H(K_{sum} | T) \,  s_{cmp}\\
\end{align*}

where index, $i$, labels each participant, index, $j$, labels every TXIN, for $N$ of them, belonging to the participant, and index, $k$, labels each TXOUT belonging to that participant. On summation from all participants, the multi-signature $(u_{\mathit{sum}}, K_{\mathit{sum}})$ represents a valid signature on the super-transaction in the same manner that would hold if this were a simple transaction.

At the end of this final signature pass, each participant should have a super-transaction that can be validated by public witnesses. But all connections between TXIN's and TXOUT's have been broken. All that anyone can see is that all TXIN are being spent, and each TXOUT must have derived from one or more of those TXIN, but no way to see which ones are associated. The leader node then publishes the super-transaction.

If a blame cycle must happen, each participant must divulge their shared secret keys. Then all other nodes can verify that all stages of the computation were performed correctly, according to the information sent previously. We then have known associations between TXIN's and TXOUT's. Any participant which cannot or will not do this is blamed for the fault, and the protocol restarts after taking note of the TXIN's associated with the cheating node.

But since secret shared keys were divulged during blame discovery, all participants must restart the protocol from the point of establishing new shared keying.

%%%%%%%%%%%%%%%%%%%
\subsection{Group Formation}
Each N epochs, the current Cosi leader and validators elect a validator which must serve as a bulletin board (bulletin board service provider, BBSP) for N next epochs, and include the public key of BBSP in the sealed block.

BBSP elections are the lottery based on distributed randomness, similar to the elections of the CoSi leader.

Each wallet intending to submit a transaction should broadcast a transaction intent message with a fresh ephemeral public key along with the signature proof of validity.

BBSP should listen to transaction intent messages from wallets and pool public keys from that messages into collections of P keys each.

On collection of P keys or on timeout of ?T? seconds, BBSP broadcasts transactions pool message, containing ephemeral public keys and signatures.

Each wallet that recognize its key in transaction pool message should sort the collection of keys from it in the ascending numerical order, form the hash of the collection, and use that hash as a random seed for the SPT session.

An SPT Session Leader is elected by forming the XOR of the hash value with the public key of each pool participant, and if the resulting value is the minimum in the list, that wallet should be chosen as an SPT Session Leader.

SPT Session Leader is responsible for publication of final super-transaction.

All other communications are p2p between members of the SPT pool.

TBD:

Values of N, P and T
Concrete design of p2p broadcast protocol
Should BBSP sign its transactions pool messages? Possibly, yes.

%%%%%%%%%%%%%%%%%%%
\section{Prevention of Direct Fraud}
Fraud can work two ways. We have already shown how it would be impossible for someone else to redirect a spending transaction in one of Mary's TXOUT UTXO's. And to steal one of her TXIN UTXO's they would need her secret key to sign the transaction, and to learn the exact amount and cloaking factor involved. So the risk is dependent on the quality of her key management.

But what about the case when Mary is the dishonest one? Or suppose she just has faulty computer code and produces an errant UTXO? What can happen?

There are two places in a UTXO where a recipient is specified without any oversight from validation witnesses. Those are in the stated ephemeral public key of the recipient, $P_{S, \delta_2}$, and in the keying for the encrypted payload which provides amount, $x$, and cloaking factors, $\gamma$ and $\delta$. 

There are a number of ways to form the encrypted payload in the UTXO's. Sam may, or may not, be able to detect an improper decryption without also forming his own Pedersen commitment with the values he recovers for $x$ and $\gamma$, and checking to see that his Pedersen commitment matches the one carried in the Bulletproof in the UTXO.

If the encrypted payload were keyed incorrectly, then Sam would not be able to read proper values for $x$ and $\gamma$, and whatever values he might obtain would not produce the same Pedersen commitment value, $C$, as carried in the Bulletproof. Sam would be unable to spend the UTXO, even if he could produce a valid signature.

And if the public key were incorrectly stated, then nobody would be able to produce a valid signature on the UTXO. 

A correct public key implies that the public key belongs to Sam, and he owns a corresponding secret key, $s_S$, so he can form a valid signature against the UTXO $\mathit{ID}$.

If Mary accidentally misstates his public key, then nobody would be able to form a signature on the UTXO $\mathit{ID}$. Or she might intentionally misstate the public key, perhaps to one of her own. Either way, there is nothing that could be detected about these situations by public witnesses. 

Suppose Mary provides Sam's correct ephemeral public key, and suppose further that she encrypted the payload in a manner that allows Sam to read amount, $x$, and $\gamma$. If she misstates either of those two values, then Sam cannot spend the UTXO because they won't match the Pedersen commitment, $C$, stored in the Bulletproof. He can't sign a transaction with that UTXO, and so he cannot spend it. Again, no witnesses could detect these kinds of errors in the UTXO. Sam will find out later when he tries to spend the UTXO.

If Mary actually sent the money back to herself, through an alias key, and she tells Sam that she sent him the money, then it becomes a dispute between two individuals. But the UTXO will be properly formed, and Mary will be able to spend her own money, and the blockchain witnesses will be satisfied that a proper transaction had been formed. There is nothing fraudulent about sending money to yourself. The fraud in this case is confined to private communication.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Prevention of Indirect Fraud}
We have shown that it is mathematically intractable to try subverting the system with witnesses watching and verifying every step of transaction formation. But what about the situation where witnesses have either been prevented from validating or else subverted by attackers into overlooking obvious invalid transactions?

If nobody were watching, then actors could fabricate arbitrary amounts of new money. The blockchain would become horribly corrupted. So witnesses are needed to police the state of blockchain integrity. How many witnesses? One seems too few, it might be possible to corrupt them. But is 1,000 witness enough? or too many? I don't think one can give a black or white answer to such questions.

Cosi networks attempt to police the state of the blockchain by requiring a BFT threshold of consensus on transaction validity. But even that cannot guarantee with certainty. 

Witnesses also offer some semblance of comfort to honest users, that their own transactions will not be mauled by attackers, or that their transactions won't be retracted after some later witness discovers corrupt blockchain state and attempts recovery.

So now we begin to approach the question of certification of blockchain state, and every transaction accepted into the blockchain needs to maintain an integral state. But what happens if that state maintenance facility becomes broken?

In the end, we have shown how to validate transactions in the blockchain. It is probably incumbent on all users to validate transactions that they are associated with before forming a new transaction based on those inputs. If every user did this, there would be no need of separate witness patrols. But even if there are witness pools, the possibility of corruption looms, and users should still rely on self-verification against party transactions that they rely upon. Users who do not perform their own validation will always run the risks of trust.

It would seem that a well policed blockchain can only offer best attempt service. There can be no absolute guarantees. But the mathematical machinery of our cryptography will provide absolute guarantees of correctness when they are used. The machinery will not corrupt. But it must be used to gain from its safety offerings.

But even here, the mathematical machinery is a hypothetical universe in which all computations are correctly carried out. Multiplication and addition never have bit errors. Real machines do suffer sporadic errors. And the best we have to overcome such errors are FEC (forward error correction) codes. The most notable is Reed-Solomon encoding which takes advantage of massive redundancy to detect and correct bit errors. Other codes perform better in some noise conditions, e.g., burst noise versus occasional bit errors.

The mathematical machinery of finite field arithmetic depends on each operation being correct. There are other kinds of crypto-systems that function more like fuzzy rendering systems, and allow for some level of noise corruption without invalidating the outcomes. Lattice-based crypto-systems come to mind here. But they are not compact systems. And our kind of cryptography would need to be adapted to a completely different paradigm, where Schnorr signatures may not even be possible.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Transaction Processing}
\subsection{Validation of New Transactions}
On entry to the witness pool, a transaction needs to be validated. The steps are:
\begin{itemize}
\item{For each TXIN, witness must locate the UTXO referred to by the $\mathit{ID}$, to find the public key, Bulletproof, and Pedersen commitment, used for signature formation. If any $\mathit{ID}$ do not point to extant UTXOs, then the entire transaction is invalid.}
\item{No two TXIN $\mathit{ID}$ can point to the same UTXO, to prevent double-spend attempts.}
\item{All of the cloaked public keys must be summed, along with all of the Pedersen commitments from the TXINs. Then all of the Pedersen commitments from the Bulletproofs in the TXOUT's must be subtracted from the sum, as well as $\mathit{Fee}$ times the $A$ curve generator. The Schnorr signature in the transaction must be checked against this summed public key.

\begin{align}
\text{TXIN} &= \{ID\} \\
ID &\rightarrow P_{M, \delta}, \text{as a result of UTXO lookup}\\
ID &\rightarrow C(x, \gamma)\\
P_{eff} &= \sum_{i \in \text{ins}}{P_i} + \sum_{i \in \text{ins}}{C_i}  - \sum_{j \in \text{outs}}{C_j} - Fee\,A\\
Sig(M, T) &= (u, K)\\
T &= \text{Entire transaction sans signature}
\end{align}

Now check that
$$u \, G = K + H_r(T, K) \, P_{\mathit{eff}}$$
If this equation holds true, then the transaction body has not been mutated, Mary has proven ownership of all UTXO mentioned in her TXIN's, and the transaction represents a proper zero balance.}
\item{The Bulletproofs in every TXOUT must be validated to ensure that amounts are within proper range, that no money is being created on credit.}
\end{itemize}

At this point, we now have a valid transaction to consider. Commitments are held inside each Bulletproof.

The paired TXIN's and their UTXO's must be marked as pending extinction, so that the UTXO's will not be available for matching with the next transaction. This prevents future double-spend attempts.

Because network communications do not guarantee message arrival order, it may be necessary to form the topological sort of incoming transactions, in case some of their TXIN's refer to UTXO's created elsewhere in the batch. An example would be where Mary spends some of her tokens, receives change back to herself, then spends that change in another transaction.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Block Validation}
The leader node of the witness group is tasked with forming a tentative block for extension of the blockchain:

\begin{itemize}
\item{Collect transactions from its mempool, validate each of them, discarding invalid transactions, and collect the remaining valid transactions into an ordered list of pending additions. 

The order must be such that all TXIN's must refer to UTXO's that are either already in the blockchain, or else the transactions containing the UTXO's must precede the TXIN transaction.}
\item{The leader sums all $\mathit{Fee}$ terms from the transactions and produces a new fee distribution transaction to send portions of the fees to deserving participants. That transaction is prepended to the ordered list of validated transactions proposed for the block. But unlike the other transactions, it will be sent in whole form to witnesses for validation since they won't have seen copies of it in their mempool.

The leader node then constructs a tentative blockchain block from this list.}
\item{The block body is constructed by stripping the TXINs and TXOUTs from each transaction, collecting these two components into two separate Merkel trees, and planting those two trees into the proposed block body.

TXIN's only need to record the UTXO $ID$ that they reference. Hence the TXIN Merkel tree is just a tree of hashes.

Since UTXO $ID$ is already a hash of the data, it can stand in for the initial hash codes in the leaf nodes. The TXOUT tree is a Merkel tree with UTXO's stored in each leaf node.

To support eventual trimming of matching TXIN and UTXO from the blockchain, the TXOUT Merkel tree needs to tag its recorded data in the leaf nodes, to indicate whether data are physically present, or just the hash of what once was there. Internal nodes of Merkel trees always point to two child nodes and carry only a hash value. Leaf nodes may, or may not, have data, and never have children.}
\item{The block header is constructed by filling in slots:
\begin{itemize}
\item{Version number}
\item{Epoch number - a monotonically increasing value that represents the height of the blockchain.}
\item{Previous block hash, computed as the hash of the block header of the current blockchain tip block.}
\item{Leader public key}
\item{
$\gamma_{blk} = \sum{\gamma_{adj}}$, the sum of all $\gamma_{adj}$ terms found in the block transactions, which includes the $\gamma_{adj}$ from the leader's fee distribution transaction.}
\item{Top hash of TXIN Merkel tree in block body}
\item{Top hash of UXTO Merkel tree in block body}
\item{Ordered list of witness public keys for current epoch. The leader node is also considered a witness during the current epoch.}
\item{BLS Multi-signature slot - to be filled in as a result of consensus on block. Note that we will be using pairing-based cryptography to support the use of short, fast, BLS signatures. BLS signatures allow the formation of multi-signatures in one pass over the witness pool.}
\item{Bitmap of signers in the multi-signature}
\end{itemize}}

The initial contents of the BLS multi-signature slots should be zero filled and, even after being filled in, never contribute to the computation of any \textit{block header hash}. All other slots are concatenated to form a header hash pre-image. But when a full hash of the block is formed for messaging purposes, the entire block, consisting of block header and block body, are considered for the hash pre-image.

\item{Form a message which contains:
\begin{itemize}
\item{The proposed block,}
\item{The fee distribution transaction,}
\item{An ordered list of transaction ID's that went into the block. Transaction ID's are computed as the hash of the transactions. Each witness should have copies of them in their own mempool.}
\item{The hash of this message. All communications about this proposed block will reference this hash value.}
\end{itemize}
The leader will sign and broadcast this message to all witnesses. The witnesses will attempt to validate the proposed block construction.}
\end{itemize}

Once constructed, the witness leader must then seek consensus for its proposed block from all the other witnesses. This happens in two passes among the witness group.

\begin{itemize}
\item{\textbf{PrePrepare Phase}: The leader broadcasts the signed prepared message, and its hash, to all witnesses in a PrePrepare message. This is the only time that the entire message will be transmitted. All further communications will refer only to its hash value.}
\item{Each witness will attempt to validate the block construction from the ordered list of transactions. 
\begin{itemize}
\item{The message must carry a valid signature from the leader node, to prevent spoofing attacks.}
\item{The message must be the first and only PrePrepare message seen from the leader for the current epoch.}
\item{The hash of the proposed block and transaction list must agree with the hash value shown in the message. This hash value will serve as a message identifier for all related messages during this epoch.}
\item{The version number shown in the block header must show the expected value.}
\item{The epoch shown in the block header must agree with the witness node's sense of the current epoch.}
\item{The previous block hash slot in the header must equal the block header hash of the current blockchain tip block.}
\item{The leader key shown in the header must match the leader known for the current epoch.}
\item{The list of known witnesses for the current epoch must agree with the list of witness keys shown in the block header.}
\item{The fee distribution transaction must be valid.}
\item{Every transaction indicated in the list of constituent transactions must be looked up in the mempool, found, validated if not already known to be valid, and the two Merkel trees must be reconstructed as the transaction list is examined. At the end of transaction examination, the two Merkel trees in the block body must be seen as constructed in the same manner.

If a witness does not have an indicated transaction in its local mempool, then it cannot validate the proposed block.}
\item{The $\gamma_{blk}$ sum in the header must equal the sum of all $\gamma_{adj}$ terms shown in the transactions.}
\item{The top hash values for the TXIN and UTXO Merkel trees, must match the values recorded in the block header.}
\end{itemize}

If a witness agrees with the proposed block construction, they sign the hash of the \textit{block header} with a BLS signature, and reply to the leader node with a Prepare message that contains the original message hash value, their signature, and a value that represents the position of their public key among the list of witnesses. 

No signature on the message is required, as that is effectively already done with the block header signature provided in the message. The leader node will protect itself from spoofing attacks by checking that the returned signature on the block header is valid, using the public key looked up in the witness list at the indicated position.

If a witness disagrees or is unable to validate the proposed block, then they should simply refrain from responding. Responses from witnesses are expected to arrive within some timeout window. At the end of that window period, the responses obtained are collected together to form a multi-signature and bitmap.

The hash being signed covers only the block header, which contains top hashes of the body Merkel trees. By signing only the block header hash, we leave allowance for future block trimming actions, without disturbing the validity of the block. Trimmed Merkel trees always continue to show the same top hash value. When forming the block header hash, the slots which will contain the eventual multi-signature and signature bitmap are excluded from the hash.

An affirmative response from a witness signifies its willingness to commit the new block to their copy of the blockchain, when asked to do so. If the epoch changes to a new epoch before they receive a valid Commit message, then they will drop the block from further consideration. 

\item{During the \textbf{PrePrepare timeout period}, the leader node accumulates valid Prepare responses from the witnesses.

Every response is checked to see if it is a valid signature on the block header hash value. The public key for the signature is looked up in the list of witnesses according to the indicated position from the response message. If the signature is valid, and the response has not already been seen, then the signature is accumulated into an accumulating multi-signature, and the position of the witness is recorded as a bit in the multi-signature bitmap. 

At the end of the PrePrepare timeout period, the leader examines the census in the multi-signature bitmap. If that witness count is above a BFT threshold for the witness pool, then we consider that a consensus has been reached. If not, then the blockchain extension is aborted. The next epoch will elect a new leader, and the process will be retried then.

If consensus has been reached, the multi-signature and the bitmap are stored in the block header. A Commit message is formed, containing the multi-signature, the bitmap, and the block message hash code. This message is signed by the leader and broadcast to all witnesses while we await another timeout period for responses.}

\item{\textbf{Commit Phase}: All witnesses receive the Commit message and attempt to validate it:

\begin{itemize}
\item{The message hash code must agree with the message hash code from the PrePrepare message seen during this epoch.}
\item{The message should have been sent from the epoch leader node. The signature on the message must be valid for the known leader public key.}
\item{The census shown in the multi-signature bitmap must exceed the BFT threshold for the witness pool.}
\item{The muilti-signature should be a valid signature against the hash of the proposed block header. To obtain the public key for the signature validation, simply add up all the public keys from the witness list as indicated by the multi-signature bitmap.}
\end{itemize}

If the Commit message is seen as valid, then the witness stores the mutli-signature and its bitmap into its local copy of the block header, and commits the block to its local copy of the blockchain. A confirmation response is formed from their BLS signature on the block header hash, their position in the list of witnesses, and the message hash code. This response is sent back to the leader.

If the witness is unable to validate the Commit message, they simply refrain from sending back a response, and discard the pending block update.}

\item{At completion of the Commit phase timeout period, the leader node accumulates all the response signatures into a multi-signature and signature bitmap. If the census of the bitmap exceeds the BFT threshold for the witness pool, and the mulit-signature is a valid signature on the hash of the block header, then a successful Commit has occurred. The leader and a BFT threshold number of witnesses have reached consensus on the block, and that block has now extended the blockchain.}
}
\end{itemize}

A successful return from each phase, and the validation of multi-signatures, checks to be sure that the multi-signature is valid, and that the number of signing witnesses exceeds a Byzantine threshold for the group. If not, then the validation round is terminated, and no consensus has been reached in this round.

Since the blockchain is an accumulating history, and each block is an immutable record, it is not possible at this stage to discard matching TXIN and UTXO's. Rather, the posted TXIN's represent a marker that, when the blockchain will next be compressed, serve to indicate which UTXO's can be discarded in the compressed chain.

During the scan through the blockchain for matching UTXO's, these markers must be noted, and if a UTXO is found which matches a noted extinction, that UTXO must be ignored in the search.

\begin{thebibliography}{99}

\bibitem{c1} Satoshi Nakamoto. ``Bitcoin: A Peer-to-Peer Electronic Cash System,'' https://bitcoin.org/bitcoin.pdf, October 31, 2008.

\bibitem{c2} Nicolas van Saberhagen. ``CryptoNote v 2.0,'' https://cryptonote.org/whitepaper.pdf, October 17, 2013.

\bibitem{c3} Shen Noether, Adam Mackenzie and Monero Core Team. ``Ring Confidential Transactions,'' https://lab.getmonero.org/pubs/MRL-0005.pdf, February, 2016.

\bibitem{c4} Benedikt Buenz, Jonathan Bootle†, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. ``Bulletproofs: Short Proofs for Confidential Transactions and More,'' Cryptology ePrint Archive, Report 2017/1066, 2017. URL: https://eprint.iacr.org/2017/1066.

\bibitem{c5} I. Miers, C. Garman, M. Green and A. D. Rubin. ``Zerocoin: Anonymous Distributed E-Cash from Bitcoin,'' 2013 IEEE Symposium on Security and Privacy, Berkeley, CA, 2013, pp. 397-411. URL: https://ieeexplore.ieee.org/document/6547123

\bibitem{c6} Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. 2012. ``From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again,'' in Proceedings of the 3rd Innovations in Theoretical Computer Science Conference (ITCS '12). ACM, New York, NY, USA, 326-349. URL: https://dl.acm.org/citation.cfm?id=2090263

\bibitem{c7} Tim Ruffing and Pedro Moreno-Sanchez. ``Mixing Confidential Transactions: Comprehensive Transaction Privacy for Bitcoin,'' Cryptology ePrint Archive, Report 2017/238, 2017. URL: https://eprint.iacr.org/2017/238

\bibitem{c8} Torben Pryds Pedersen. ``Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing,'' Advances in Cryptology --- CRYPTO '91", Springer Berlin Heidelberg, 1992, pages 129--140.

\bibitem{c9} Miguel Castro and Barbara Liskov. ``Practical Byzantine Fault Tolerance,'' Proceedings of the Third Symposium on Operating Systems Design and Implementation, 1999, pages 173--186. 

\bibitem{c10} Ewa Syta, Iulia Tamas, Dylan Visher, David Isaac Wolinsky, Philipp Jovanovic, Linus Gasser, Nicolas Gailly, Ismail Khoffi, Bryan Ford. ``Keeping Authorities “Honest or Bust” with Decentralized Witness Cosigning,'' arXiv:1503.08768v4 [cs.CR], 30 May 2016. URL: https://arxiv.org/pdf/1503.08768.pdf

\bibitem{c11} Eleftherios Kokoris-Kogias, Philipp Jovanovic, Nicolas Gailly,
Ismail Khoffi, Linus Gasser, and Bryan Ford. ``Enhancing Bitcoin Security and Performance with Strong Consistency via Collective Signing,'' arXiv:1602.06997v3 [cs.CR], 1 Aug 2016. URL: https://arxiv.org/pdf/1602.06997v3.pdf

\bibitem{c12} Ewa Syta, Philipp Jovanovic, Eleftherios Kokoris Kogias, Nicolas Gailly, Linus Gasser, Ismail Khoffi, Michael J. Fischer, Bryan Ford. ``Scalable Bias-Resistant Distributed Randomness,'' Cryptology ePrint Archive, Report 2016/1067, 2016. URL: https://eprint.iacr.org/2016/1067.

\bibitem{c13} Ignacio Cascudo, Bernardo David. ``SCRAPE: Scalable Randomness Attested by Public Entities,'' Applied Cryptography and Network Security, Springer International Publishing, 2017, pages 537--556.

\bibitem{c14} Youliang Tian, Changgen Peng, Renping Zhang, Yuling Chen. ``A practical publicly verifiable secret sharing scheme based on bilinear pairing,'' 2nd International Conference on Anti-counterfeiting, Security and Identification, IEEE, 2008.

\end{thebibliography}

\end{document}
